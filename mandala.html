<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/tr/html4/loose.dtd">
<html lang="en">
<head>
    <title>Make a Mandala</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="author" content="Bruce Cooner">
    <meta name="description" content="graphics tinkering">

    <!-- TODO: do we need type attributes here? -->
    <!-- TODO: can we push the dependencies into their dependent modules?  -->
    <link rel="stylesheet" type="text/css" href="mandalaStyles.css">
    <script src="libs/jquery-3.1.1.min.js"></script>
    <script src="libs/utility.js"></script>
    <script src="libs/myRangeInput.js"></script>
    <script src="libs/WatchedValue.js"></script>
    <script src="libs/debugDiv.js"></script>
    <script src="libs/fnc2d.js"></script>

    <script src="graphicsCommands.js"></script>
    <script src="graphicsEngine.js"></script>

    <script src="colorJourney.js"></script>
    <script src="drawModeLines.js"></script>
    <script src="drawModeContinuous.js"></script>
    <script src="drawModeCircles.js"></script>
    <script src="drawModeErase.js"></script>
    <script src="cursorEngine.js"></script>
    <script src="drawEngine.js"></script>
    <script src="mandala.js"></script>
    <!-- <link rel='shortcut icon' type='image/x-icon' href='/favicon.ico' /> -->
</head>
<body onload="onBodyLoad()">

   <!--
   TODO:
   BUGS:
      -stupid composite thing with undo buffer, boo
      -freeform should allow single pixels
      -jerkiness in continuous draw mode? seems okay, for now
      -eraser doesn't work unless moving, can't click-erase
      -eraser needs to perform true transparency on canvas
   -FEATURES:
      -color selection?
      -line width selection
      -draw mode specific config? (line width, eraser size, etc.)
      -guide opacity?
      -guide distance markers
      -undo
      -help!
      -unobtrusive way to see num petals
      -configurable color journey
      -line choices (size, shape, helix?, etc.)
      -confirm dialog on clear
   -TECH:
      -better way to view than giant base-64 string?
      -paths instead of lines? Or maybe variable point lines?
      -have continuous draw use paths
      -mandala can recreate from parameters
      -undo saves/reuses mandala parameters to recreate strokes
      -officially migrate to K&R brackets (grumble)
      -better way to trigger renders (pub/sub maybe?)
      -detect when graphics execute does/does not get an array!
      -should the canvas just fill the damn window?
      -render command arrays with workers?
      -smoother freeform lines (ugh)
      -store local origin/transform in graphicsEngine, work completely in mandala space
      -get handle on naming functions in mandala, general functionality
      -clean up logic/functionality around the mirror stuff!
      -use library for event listening attach
   -LAYOUT:
   -->

   <script>
   // consts
   const canvasSize = 800

   const drawingCanvasId = 'drawingCanvasId'
   const guidesCanvasId = 'guidesCanvasId'
   const cursorCanvasId = 'cursorCanvasId'
   const undoBufferCanvasId = 'undoBufferCanvasId'

   // order in which canvases are created
   const canvasOrder = [ drawingCanvasId, undoBufferCanvasId, guidesCanvasId, cursorCanvasId ]

   // ==========================================================================
   const delayBeforeColorJourneyStart = 55
   const minColorJourneySpeed = 3
   const maxColorJourneySpeed = 60 * 3
   const defaultColorJourneyScale = 0.5

   // drawing
   var drawEngine = null
   var colorJourney = null

   // --------------------------------------------------------------------------
   // returns color speed given a normalized scale value
   function getColorJourneySpeed(scale)
   { return minColorJourneySpeed + ((maxColorJourneySpeed-minColorJourneySpeed)*scale)}

   // --------------------------------------------------------------------------
   // receives:value-normalized speed of color speed transitions
   function setColorJourneySpeed(scale)
   {
      console.log(`setting color journey scale:${scale}`)
      colorJourney.setSpeed(getColorJourneySpeed(1 - scale))
   }

   // --------------------------------------------------------------------------
   var menuDivIds = ['petalsConfigDivId', 'colorsConfigDivId']

   // --------------------------------------------------------------------------
   function showConfigMenu(menuDivId)
   {
      // console.log(`showMenu : ${menuDivId}`)
      var numDivs = $('.configDivClass').length
      // console.log(`num divs: ${numDivs}`)

      $('.configDivClass').each( function()
      {
         isShown = this.id == menuDivId

         $(this).toggleClass('visible', isShown)
         $(this).toggleClass('menu_transparent', !isShown)
      })
   }

   // --------------------------------------------------------------------------
   function dismissConfigMenus()
   {
      $('.configDivClass').each( function()
      {
         $(this).toggleClass('visible', false)
         $(this).toggleClass('menu_transparent', true)
      })
   }

   // --------------------------------------------------------------------------
   // canvases
   // receives: config {canvasOrder, canvasSize }
   // --------------------------------------------------------------------------
   function createCanvases( config )
   {
      var canvasContainerEl = document.getElementById('canvasContainerId')

      var left = `${canvasContainerEl.clientWidth / 2 - canvasSize / 2}px`
      var top = `${canvasContainerEl.clientHeight / 2 - canvasSize / 2}px`

      canvasOrder.forEach( function(currentId)
      {
         cvs = document.createElement("canvas")

         cvs.id = currentId
         cvs.width = config.canvasSize;
         cvs.height = config.canvasSize;

         cvs.style.left = left
         cvs.style.top  = top

         canvasContainerEl.appendChild(cvs)
      })

   }

   // ==========================================================================
   // undo buffer stuff
   var undoBuffer = []
   const undoBufferSize = 5
   let i = 0
   for (i = 0; i < undoBufferSize; i += 1)
   {
      undoBuffer[i] = []
   }

   // last USED index
   var undoBufferIndex = 0

   // --------------------------------------------------------------------------
   function receiveDrawStroke(strokeCommands)
   {
      console.log(`adding stroke to undo buffer, current index:${undoBufferIndex}`)

      // advance to next if there's something at current (i.e. it got used)
      if (undoBuffer[undoBufferIndex].length > 0)
      {
         console.log(`advancing...`)
         undoBufferIndex = (undoBufferIndex + 1) % undoBufferSize
      }

      // already something at new index?
      if (undoBuffer[undoBufferIndex].length > 0)
      {
         console.log(`drawing undo buffer index ${undoBufferIndex}`)
         commands = [ GraphicsCommands.setDrawParameter('strokeStyle', '#000000')]
         commands = commands.concat(undoBuffer[undoBufferIndex])
         drawOutput(commands);
      }

      // transform...
      transformedStroke = transformDrawStroke(strokeCommands)

      console.log(`adding stroke at index ${undoBufferIndex}`)
      undoBuffer[ undoBufferIndex ] = transformedStroke

      renderUndoCanvas()
   }
   // --------------------------------------------------------------------------
   function renderUndoCanvas()
   {
      undoBufferGraphicsEngine.execute( [GraphicsCommands.clear()] )
      undoBufferGraphicsEngine.execute( [GraphicsCommands.setDrawParameter('strokeStyle','#000000')])

      undoBuffer.forEach( function(currentStroke) {
         undoBufferGraphicsEngine.execute(currentStroke)
      })
   }

   // --------------------------------------------------------------------------
   function undo()
   {
      console.log(`undoing... buffer index : ${undoBufferIndex}`)

      if (undoBuffer[undoBufferIndex].length > 0)
      {
         console.log(`something there, undoin'`)
         undoBuffer[undoBufferIndex] = []
         undoBufferIndex = (undoBufferIndex == 0) ? undoBufferSize - 1 : undoBufferIndex - 1
      }

      console.log(`new buffer index : ${undoBufferIndex}`)

      renderUndoCanvas()
   }

   // --------------------------------------------------------------------------
   // TODO: ugh, more dynamic canvas fetch!
   function getDrawCanvas()
   {
      return document.getElementById(drawingCanvasId)
   }
   function getInputCanvas()
   {
      // currently topmost one
      return document.getElementById(cursorCanvasId)
   }
   function getGuidesCanvas()
   {
      // currently topmost one
      return document.getElementById(guidesCanvasId)
   }
   function getUndoBufferCanvas()
   {
      return document.getElementById(undoBufferCanvasId)
   }

   // ----------------------------------------------------------
   // drawing
   // ---------------------------------------------------------
   function toCanvasSpace(point)
   {
      return new fnc2d.Point(point).translate(canvasSize / 2)
   }
   function toMandalaSpace(point)
   {
      return new fnc2d.Point(point).translate(-1 * (canvasSize / 2))
   }

   // ---------------------------------------------------------
   function renderGuides()
   {
      commands = [ GraphicsCommands.clear() ]
      commands.push( GraphicsCommands.setDrawParameter('lineDash', [0,0]) )

      if ( mandala.drawGuides )
      {
         lines = mandala.RenderGuides(canvasSize / 2)

         linesCommands = lines.guideLines.map( function(lineParams)
         {
            return GraphicsCommands.line( toCanvasSpace(lineParams.p1),
                                          toCanvasSpace(lineParams.p2) )
         })

         commands = commands.concat( linesCommands )

         if (lines.halfGuideLines.length > 0)
         {
            linesCommands = lines.halfGuideLines.map( function(lineParams)
            {
               return GraphicsCommands.line( toCanvasSpace(lineParams.p1),
                                             toCanvasSpace(lineParams.p2) )
            })

            commands = commands.concat([ GraphicsCommands.setDrawParameter('lineDash', [5,3])] )
            commands = commands.concat( linesCommands )
         }
      }
      guidesGraphicsEngine.execute(commands)
   }

   // ---------------------------------------------------------
   function render()
   {
      renderGuides()
   }

   // --------------------------------------------------------------------------
   // consolidates information needed to render a draw stroke in the mandala object
   function buildMandalaRender(graphicsCommands, drawParameters, clearCanvas)
   {
      if (null === drawParameters)
      {
         drawParameters = {}
      }

      // if color not specified, add it here
      // if user color selection is added, it'd go here I guess
      if (!drawParameters.hasOwnProperty('strokeStyle'))
      {
         drawParameters.strokeStyle = '#000000'
      }

      // note that mandala has no knowledge of element/canvas sizes
      let canvasOrigin = new fnc2d.Point( canvasSize/2, canvasSize/2)

      return { commands:graphicsCommands,
               mandalaState:mandala.getState(),
               mirrorLine:mandala.mirrorLine,
               drawParameters: drawParameters,
               origin:canvasOrigin,
               clear:clearCanvas}
   }

   // --------------------------------------------------------------------------
   // graphicsCommands : [ {graphic command}, ... ]
   function drawOutput(graphicsCommands)
   {
      let renderObject = buildMandalaRender(graphicsCommands, {strokeStyle:'#000000'}, false)

      // TODO : save object or something?

      // dispatch it to the mandala
      mandala.render(renderObject, outputGraphicsEngine)
   }

   // --------------------------------------------------------------------------
   // handles mandala/reflection concerns
   // receives:graphicsCommands : [ {graphic command}, ... ]
   function drawCursorOutput(graphicsCommands)
   {
      let renderObject = buildMandalaRender(graphicsCommands, {strokeStyle:'#000000'}, true)

      // TODO : save object or something?

      // dispatch it to the mandala
      mandala.render(renderObject, cursorGraphicsEngine)
   }

   // --------------------------------------------------------------------------
   // tell this module when draw cursor moves
   // receives: point{x,y} (in canvas space)
   function onCursorMove(point)
   {
      debugDiv.add('cursormove', `(main)cursor:${point.str()}`)
      if (mandala.mirrorGuides )
      {
         mirrorLine = mandala.NearestGuideLine(point)

         mandala.setMirrorLine( mirrorLine )
         debugDiv.add('mirrorLine1', `m. line p1:${mirrorLine.p1.x},${mirrorLine.p1.y}`)
         debugDiv.add('mirrorLine2', `m. line p2:${mirrorLine.p2.x},${mirrorLine.p2.y}`)
      }

      renderCursorGraphics()
   }

   // --------------------------------------------------------------------------
   function renderCursorGraphics()
   {
      cursorGraphics = drawEngine.getCursorGraphics()
      drawCursorOutput(cursorGraphics)
   }

   // --------------------------------------------------------------------------
   // graphics engines TODO: don't particularly like this type name
   var cursorGraphicsEngine = null
   var outputGraphicsEngine = null
   var guidesGraphicsEngine = null

   function initGraphicsEngines()
   {
      cursorGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:getInputCanvas()})
      outputGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:getDrawCanvas()})
      guidesGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:getGuidesCanvas()})
      undoBufferGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:getUndoBufferCanvas()})
   }

   // --------------------------------------------------------------------------
   // INTERFACE UTILITY STUFF
   var numPetalsTimeoutFunc = 0
   function showNumPetals(num)
   {
      $('#numPetalsSpanId').html(num)
      $('#numPetalsSpanId').addClass('shown')
      if (numPetalsTimeoutFunc != 0)
      {
         clearTimeout(numPetalsTimeoutFunc);
      }
      numPetalsTimeoutFunc = setTimeout(function(){ $('#numPetalsSpanId.shown').removeClass('shown').addClass('transparent') }, 1000);
   }

   // --------------------------------------------------------------------------
   function toggleMirroring()
   {
      mirrorGuides.set( !mandala.mirrorGuides )

      if ( false == mandala.mirrorGuides )
      {
         mandala.mirrorLine = null

         debugDiv.remove('mirrorLine1')
         debugDiv.remove('mirrorLine2')
      }
      else
      {
         point = toMandalaSpace(drawEngine.cursorCoords)
         // select closest guide line
         mirrorLine = mandala.NearestGuideLine(point)
         mandala.setMirrorLine( mirrorLine )
      }

      $('#mirrorGuidesCheckboxId')[0].checked = mandala.mirrorGuides

      renderCursorGraphics()
   }

   // --------------------------------------------------------------------------
   function toggleShowGuides()
   {
      drawGuides.set( !mandala.drawGuides ) // mandala.drawHalfGuides ? false : true )<<this works long as initial state is right
      $('#showGuidesCheckboxId')[0].checked = mandala.drawGuides
      renderGuides()
   }

   // --------------------------------------------------------------------------
   function toggleHalfGuides()
   {
      drawHalfGuides.set( !mandala.drawHalfGuides ) // mandala.drawHalfGuides ? false : true )<<this works long as initial state is right
      $('#halfGuidesCheckboxId')[0].checked = mandala.drawHalfGuides
      renderGuides()
   }

   // --------------------------------------------------------------------------
   // function onWheel(event)
   // {
   //    console.log(`wheel detail:${event.originalEvent.detail}`)
   // }

   // --------------------------------------------------------------------------
   function bodyOnKeyUp(event)
   {
      switch (event.originalEvent.key)
      {
         case 'x':
         case 'X':
            outputGraphicsEngine.execute( [GraphicsCommands.clear()] )
         break;
         case '<':
         case ',':
            onHalvePetalsButton()
         break;
         case '>':
         case '.':
            onDoublePetalsButton()
         break
         case 'm':
         case 'M':
            toggleMirroring()
         break
         case 'h':
         case 'H':
            toggleHalfGuides()
         break
         case 'g':
         case 'G':
            toggleShowGuides()
         break;
         // disable undo, for now
         // case 'u':
         // case 'U':
         //    undo()
         // break;
      }
   }

   // --------------------------------------------------------------------------
   // SETUP
   // --------------------------------------------------------------------------
   var mandala = new Mandala.Mandala()

   var numPetals = WatchedValue.Create(mandala.numPetals,
      [function(value) {   mandala.numPetals = value
                           renderGuides()
                           showNumPetals(value)
                           }])

   var petalsOffset = WatchedValue.Create(mandala.petalsOffset,
      [function(value) {   mandala.petalsOffset = value
                           renderGuides() }])

   var drawHalfGuides = WatchedValue.Create(mandala.drawHalfGuides,
      [ function(value) {  mandala.drawHalfGuides = value
                           renderGuides() }])

   var drawGuides = WatchedValue.Create(mandala.drawGuides,
      [ function(value) {  mandala.drawGuides = value
                           renderGuides() }])

   var mirrorGuides = WatchedValue.Create(mandala.mirrorGuides,
      [ function(value) { mandala.mirrorGuides = value }])

   // ---------------------------------------------------------
   // handlers
   // ---------------------------------------------------------
   function onBodyLoad()
   {
      createCanvases({canvasOrder, canvasSize})

      $('#cursorCanvasId')[0].oncontextmenu = function(){return false;}
      // TODO: set opacity dynamically
      $('#guidesCanvasId')[0].style.opacity = 0.5

      // --- DUCTWORK ---
      // num petals
      let numPetalsRangeCallback = myRangeInput.createRange({id:'numPetalsId',
         containerId:'numPetalsRangeContainer',
         onInputHandler:numPetals.set,
         initialValue:mandala.numPetals,
         min:Mandala.minPetals, max:Mandala.maxPetals, step:1})

      // hook range input up to external changes in num petals value
      numPetals.addSetCallback(numPetalsRangeCallback)

      // petal offset
      let petalsOffsetCB = myRangeInput.createRange({id:'petalsOffsetId',
         containerId:'petalsOffsetRangeContainer',
         onInputHandler:petalsOffset.set,
         initialValue:mandala.petalsOffset,
         min:-0.5, max:0.5, step:0.1})

      // --- graphics setup ---
      initGraphicsEngines()

      let drawEngineTranslation = new fnc2d.Point( -canvasSize / 2, -canvasSize /2)
      drawEngine = new DrawEngine.DrawEngine({ inputCanvas:getInputCanvas(),
                                                renderCursorGraphics:renderCursorGraphics,
                                                drawOutputGraphics:drawOutput,
                                                cursorMoveCallback:onCursorMove,
                                                commitDrawStroke:receiveDrawStroke,
                                                coordsTranslation:drawEngineTranslation})

      // --- UI INIT ---
      // TODO: better way to do this?
      $('#drawModeSelectId')[0].value = drawEngine.currentDrawMode.name
      // checkboxes
      $('#halfGuidesCheckboxId')[0].checked = mandala.drawHalfGuides
      $('#showGuidesCheckboxId')[0].checked = mandala.drawGuides
      $('#mirrorGuidesCheckboxId')[0].checked = mandala.mirrorGuides

      // DRAW
      render()

      // TESTING stuff
      // outputGraphicsEngine.execute(GraphicsCommands.line({x:0,y:0},{x:400,y:400}))
      // outputGraphicsEngine.execute(GraphicsCommands.setDrawParameter(''))
      //
      // let testOrigin = {x:canvasSize/2, y:canvasSize/2}
      //
      // // set origin
      // let testTranslateCommand = GraphicsCommands.setDrawParameter('translate',testOrigin)
      // outputGraphicsEngine.execute(testTranslateCommand)
      //
      // outputGraphicsEngine.execute(GraphicsCommands.setDrawParameter('strokeStyle', '#FF0000'))
      // outputGraphicsEngine.execute(GraphicsCommands.line({x:0,y:0},{x:-10,y:0}))
      // outputGraphicsEngine.execute(GraphicsCommands.setDrawParameter('strokeStyle', '#00FF00'))
      // outputGraphicsEngine.execute(GraphicsCommands.line({x:0,y:0},{x:10,y:0}))
      //
      // outputGraphicsEngine.execute(GraphicsCommands.setDrawParameter('strokeStyle', '#0000FF'))
      // outputGraphicsEngine.execute(GraphicsCommands.line({x:0,y:0},{x:0,y:10}))
      //
      //
      // outputGraphicsEngine.execute(GraphicsCommands.setDrawParameter('strokeStyle', '#00FF00'))
      // let i = 0
      // let testNumPetals = 8
      // let radiansPerTestPetal = Math.PI * 2 / testNumPetals
      //
      // outputGraphicsEngine.execute(GraphicsCommands.setDrawParameter('strokeStyle', '#00FFFF'))
      // let lineCommand = GraphicsCommands.line({x:10,y:10},{x:10,y:canvasSize/2})
      // let rotCommand = GraphicsCommands.setDrawParameter('rotate', radiansPerTestPetal)
      // outputGraphicsEngine.execute(GraphicsCommands.setDrawParameter('strokeStyle', '#0000FF'))
      //
      // for ( i = 0; i < testNumPetals; i += 1)
      // {
      //    outputGraphicsEngine.execute(lineCommand)
      //    // outputGraphicsEngine.execute(rotCommand)
      // }

      // color journey stuff
      let colorJourneySpeedCallback = myRangeInput.createRange({id:'colorJourneySpeedId',
            containerId:'colorJourneySpeedContainer',
            onInputHandler:setColorJourneySpeed,
            initialValue:defaultColorJourneyScale,
            min:0, max:1, step:0.01})

      colorJourney = new ColorJourney.ColorJourney({node:document.getElementsByTagName('body')[0],
                                       departureTime:delayBeforeColorJourneyStart,
                                       changePeriod:getColorJourneySpeed(defaultColorJourneyScale)})

      $('body').on('keyup', bodyOnKeyUp)
      // $('body').on('mousewheel DOMMouseScroll', onWheel)
   }

   // ---------------------------------------------------------
   function onClearDrawingButton()
   {
      outputGraphicsEngine.execute( [GraphicsCommands.clear()] )
   }

   // ---------------------------------------------------------
   function onDoublePetalsButton()
   {
      numPetals.set(Math.min(mandala.numPetals * 2, Mandala.maxPetals))
   }

   // ---------------------------------------------------------
   function onHalvePetalsButton()
   {
      if (0 == mandala.numPetals % 2 && mandala.numPetals >= 4)
      {
         numPetals.set(mandala.numPetals / 2)
      }
   }

   // ----------------------------------------------------------------------
   function onPlusOneSpokeButton()
   {
      numPetals.set(Math.min(mandala.numPetals + 1, Mandala.maxPetals))
   }
   function onMinusOneSpokeButton()
   {
      if (mandala.numPetals > 2)
      {
         numPetals.set(mandala.numPetals - 1)
      }
   }

   // -----------------------------------------------------------------------
   function onChangeDrawHalfGuides(event)
   {
      //TODO : check this out in different browsers
      checked = event.target.checked

      drawHalfGuides.set( checked ) // mandala.drawHalfGuides ? false : true )<<this works long as initial state is right
   }

   // -----------------------------------------------------------------------
   function onChangeDrawGuides(event)
   {
      //TODO : check this out in different browsers
      checked = event.target.checked

      drawGuides.set( checked ) // mandala.drawHalfGuides ? false : true )<<this works long as initial state is right
   }

   // -----------------------------------------------------------------------
   function onChangeMirrorGuides(event)
   {
      checked = event.target.checked

      mirrorGuides.set(checked)

      if ( false == mandala.mirrorGuides )
      {
         mandala.mirrorLine = null
      }
   }

   // --------------------------------------------------------------------------
   function onChangeDrawMode(event)
   {
      console.log(`change draw mode to: ${event.target.value}`)
      drawEngine.setDrawMode(event.target.value)
   }

   // --------------------------------------------------------------------------
   // copies specified canvases, (which is assumed to have no background), fills
   // background of new canvas (white), and opens in new window
   function viewCanvas(fromCanvas)
   {
      var oldCtx = fromCanvas.getContext("2d")

      var newCanvas = document.createElement("canvas")
      var newCtx = newCanvas.getContext("2d")

      newCanvas.id = 'Mandala'
      newCanvas.width = fromCanvas.width
      newCanvas.height = fromCanvas.height

      var oldCtx = fromCanvas.getContext("2d")
      data = oldCtx.getImageData(0, 0, newCanvas.width, newCanvas.height)
      newCtx.putImageData( data, 0, 0 )

      // var compositeOperation = oldCtx.globalCompositeOperation
      newCtx.globalCompositeOperation = 'destination-over'
      newCtx.fillStyle = '#FFFFFF'
      newCtx.fillRect(0,0, newCanvas.width, newCanvas.height)

       var dataURL = newCanvas.toDataURL("image/jpeg");

       window.open(dataURL)
   }

   // --------------------------------------------------------------------------
   function onClickViewButton()
   {
      // canvasEl = document.getElementById(drawingCanvasId)
      // this is dumb, for some reason undo and draw buffers don't composite correctly
      viewCanvas(getDrawCanvas())
   }

   // --------------------------------------------------------------------------
   function onPlayPauseColorJourneyButton()
   {
      playState = colorJourney.togglePlaying()

      $('#playPauseColorJourneyButtonId')[0].innerHTML = playState ? '||' : ' >'
   }

   // --------------------------------------------------------------------------
   function onNextColorButton()
   {
      colorJourney.nextColor()
   }

   </script>

   <ul id="mainMenuId">
      <li><img src='assets/flower.png' width='25px' height='25px' onclick='showConfigMenu(`petalsConfigDivId`)'/></li>
      <li><img src='assets/colors.png' width='25px' height='25px' onclick='showConfigMenu(`colorsConfigDivId`)'/></li>
   </ul>

   <div id='petalsConfigDivId' class='menu_transparent configDivClass'>
      <button class='dismissButton flatButton' onclick='dismissConfigMenus()'>X</button>
      <br><br>
      <div id='numPetalsRangeContainer' style='display:inline-block;'></div>
      <br>
      <button id='halveSpokesButtonId' class='flatButton' onclick='onHalvePetalsButton()'>&lt;&lt;</button>
      <button id='PlusOneSpokeButtonId' class='flatButton' onclick='onMinusOneSpokeButton()'>-</button>
      <button id='PlusOneSpokeButtonId' class='flatButton' onclick='onPlusOneSpokeButton()'>+</button>
      <button id='doubleSpokesButtonId' class='flatButton' onclick='onDoublePetalsButton()'>&gt;&gt;</button>
      <br>
      <div id='petalsOffsetRangeContainer' style='display:inline-block;'></div>
      <br>
      <span class="highlightletter">g</span><span>uides :</span><input type='checkbox' id='showGuidesCheckboxId' checked='true' onchange="onChangeDrawGuides(event)">
      <br>
      <span class="highlightletter">h</span><span>alf:</span><input type='checkbox' id='halfGuidesCheckboxId' checked='true' onchange="onChangeDrawHalfGuides(event)">
      <br>
      <span class="highlightletter">m</span><span>irror:</span><input type='checkbox' id='mirrorGuidesCheckboxId', checked='false' onchange='onChangeMirrorGuides(event)'>
      <br>
      <br>
      <select id='drawModeSelectId' onchange='onChangeDrawMode(event)'>
         <option value='freeform'>Freeform</option>
         <option value='lines'>Lines</option>
         <option value='circles'>Circles</opotion>
      </select>
      <br><br>
      <button id='clearDrawingButtonId' class='flatButton' onclick='onClearDrawingButton()'>Clear (<span class='highlightletter'>X</span>)</button>
      <button id='viewButtonId' class='flatButton' onclick='onClickViewButton()'>View</button>
   </div>

   <div id='colorsConfigDivId' class='menu_transparent configDivClass'>
      <span>color journey</span>
      <button class='dismissButton flatButton' onclick='dismissConfigMenus()'>X</button>
      <br><br>
      <button id='playPauseColorJourneyButtonId' class='flatButton' onclick='onPlayPauseColorJourneyButton()'>||</button>
      <button id='nextColorButtonId' class='flatButton' onclick='onNextColorButton()'>&gt;&gt;</button>
      <br>
      <!-- <img src='assets/hslhuecircle.png'/> -->
      <br>
      <span>speed</span>
      <div id='colorJourneySpeedContainer' style='display:inline-block;'></div>
      <br>
   </div>

   <div id="canvasContainerId">
      <span id='numPetalsSpanId' class='transparent'>69</span>
   </div>
</body>
