<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/tr/html4/loose.dtd">
<html lang="en">
<head>
    <title>Make a Mandala</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="author" content="Bruce Cooner">
    <meta name="description" content="graphics tinkering">

    <!-- TODO: do we need type attributes here? -->
    <!-- TODO: can we push the dependencies into their dependent modules?  -->
    <link rel="stylesheet" type="text/css" href="mandalaStyles.css">
    <script src="libs/jquery-3.1.1.min.js"></script>
    <script src="libs/maths.js"></script>
    <script src="libs/utility.js"></script>
    <script src="libs/myRangeInput.js"></script>
    <script src="libs/WatchedValue.js"></script>

    <script src="GraphicsCommands.js"></script>
    <script src="GraphicsEngine.js"></script>

    <script src="drawModeLines.js"></script>
    <script src="drawModeContinuous.js"></script>
    <script src="drawEngine.js"></script>
    <script src="mandala.js"></script>
    <!-- <link rel='shortcut icon' type='image/x-icon' href='/favicon.ico' /> -->
</head>
<body onload="onBodyLoad()">

   <!--
   TODO:
   FEATURES:
   -save drawing canvas to file?
   -color selection
   -line width selection
   -show/hide config
   -show/hide guides, guide opacity?
   -guide distance markers
   -print option?
   -mirror around spokes
   -should be making svg's?
   BUGS:
   -jerkiness in continuous draw mode
   -->

   <script>
   // consts
   const canvasSize = 800

   const drawingCanvasId = 'drawingCanvasId'
   const guidesCanvasId = 'guidesCanvasId'
   const cursorCanvasId = 'cursorCanvasId'

   // order in which canvases are created
   const canvasOrder = [ drawingCanvasId, guidesCanvasId, cursorCanvasId ]

   const canvasX = 500
   const canvasY = 0

   // drawing
   var lastPoint = null

   // tracking crap
   var buttonDown = false

   var drawEngine = null

   // --------------------------------------------------------------------------
   // canvases
   // receives: config {canvasOrder, canvasSize, canvasX, canvasY}
   // --------------------------------------------------------------------------
   function createCanvases( config )
   {
      var bod = $("body")[0]

      canvasOrder.forEach( function(currentId)
      {
         cvs = document.createElement("canvas")

         cvs.id = currentId
         cvs.width = config.canvasSize;
         cvs.height = config.canvasSize;
         cvs.left = config.canvasX;
         cvs.top = config.canvasY;

         bod.appendChild(cvs)
      })

      // cvs = document.createElement("canvas")
      //
      // cvs.id = drawingCanvasId
      // cvs.width = canvasWidth;
      // cvs.height = canvasHeight;
      // cvs.left = canvasX;
      // cvs.top = canvasY;
      //
      // bod.appendChild(cvs)
      //
      // cvs2 = document.createElement("canvas")
      // cvs2.id = guidesCanvasId
      // cvs2.width = canvasWidth;
      // cvs2.height = canvasHeight;
      // cvs2.left = canvasX;
      // cvs2.top = canvasY;
      //
      // bod.appendChild(cvs2)
   }

   // --------------------------------------------------------------------------
   // TODO: ugh, more dynamic canvas fetch!
   function getDrawCanvas()
   {
      return document.getElementById(drawingCanvasId)
   }
   function getInputCanvas()
   {
      // currently topmost one
      return document.getElementById(cursorCanvasId)
   }
   function getGuidesCanvas()
   {
      // currently topmost one
      return document.getElementById(guidesCanvasId)
   }

   // ----------------------------------------------------------
   // drawing
   // ---------------------------------------------------------
   function toCanvasSpace(point)
   {
      return { x:point.x + (canvasSize / 2), y:point.y + (canvasSize /2) }
   }
   function toMandalaSpace(point)
   {
      return { x:point.x - (canvasSize / 2), y:point.y - (canvasSize /2) }
   }

   // ---------------------------------------------------------
   function renderGuides()
   {
      lines = mandala.RenderGuides(canvasSize / 2)

      // TODO: configure
      getGuidesCanvas().style.opacity = 0.5

      var ctx = getGuidesCanvas().getContext("2d");
      ctx.clearRect(0, 0, cvs.width, cvs.height);

      if (lines.guideLines.length > 0)
      {
         ctx.setLineDash([0,0]);

         lines.guideLines.forEach( function(currentLine)
         {
            lineStartCanvas = toCanvasSpace(currentLine.lineStart)
            lineEndCanvas = toCanvasSpace(currentLine.lineEnd)
            ctx.beginPath()
            ctx.moveTo( lineStartCanvas.x, lineStartCanvas.y )
            ctx.lineTo( lineEndCanvas.x, lineEndCanvas.y )
            ctx.stroke()
         })
      }

      if (lines.halfGuideLines.length > 0)
      {
         var ctx = getGuidesCanvas().getContext("2d");
         ctx.setLineDash([5,3]);

         lines.halfGuideLines.forEach( function(currentLine)
         {
            lineStartCanvas = toCanvasSpace(currentLine.lineStart)
            lineEndCanvas = toCanvasSpace(currentLine.lineEnd)
            ctx.beginPath()
            ctx.moveTo( lineStartCanvas.x, lineStartCanvas.y )
            ctx.lineTo( lineEndCanvas.x, lineEndCanvas.y )
            ctx.stroke()
         })
      }
   }

   // ---------------------------------------------------------
   function render()
   {
      renderGuides()
   }

   // --------------------------------------------------------------------------
   // these functions take a GraphicsCommand from the DrawEngine and turn them
   // into a set of commands relevant to the mandala (i.e. reflected around
   // the center, etc.)
   function transformLineCommand(lineCommand)
   {
      parameters = lineCommand.parameters

      lines = mandala.RenderLine( { lineStart:toMandalaSpace(parameters.lineStart),
                                    lineEnd:toMandalaSpace(parameters.lineEnd)} )

      newCommands = []

      lines.forEach( function(currentLine)
      {
         newCommands.push( GraphicsCommands.line(  toCanvasSpace(currentLine.lineStart),
                                                   toCanvasSpace(currentLine.lineEnd) ) )
      })

      return newCommands
   }

   // --------------------------------------------------------------------------
   function passThroughCommand(command)
   { return command }

   // --------------------------------------------------------------------------
   var transformHandlers =
   {
      [GraphicsCommands.cmd_clear]:passThroughCommand,
      [GraphicsCommands.cmd_line]:transformLineCommand,
   }

   // --------------------------------------------------------------------------
   // graphicsCommands : [ {graphic command}, ... ]
   function drawOutput(graphicsCommands)
   {
      graphicsCommands.forEach( function(currentCommand)
      {
         transformedCommands = transformHandlers[currentCommand.command](currentCommand)

         outputGraphicsEngine.execute(transformedCommands)
      })
   }

   // --------------------------------------------------------------------------
   // parameters : { x, y }
   // note : canvas space
   // function draw_Cursor_Point_Marker(parameters)
   // {
   //    cursorCanvasEl = document.getElementById(cursorCanvasId)
   //
   //    var ctx = cursorCanvasEl.getContext("2d");
   //    ctx.clearRect(0, 0, cvs.width, cvs.height);
   //    ctx.setLineDash([0,0]);
   //
   //    ctx.beginPath()
   //    ctx.moveTo( parameters.lineStart.x, parameters.lineStart.y )
   //    ctx.lineTo( parameters.lineEnd.x, parameters.lineEnd.y )
   //    ctx.stroke()
   // }

   // --------------------------------------------------------------------------
   // SETUP
   // --------------------------------------------------------------------------
   var mandala = new Mandala.Mandala()

   var numPetals = WatchedValue.Create(mandala.numPetals,
      [function(value) {   mandala.numPetals = value
                           renderGuides()
                           $('#numPetalsSpanId').html(value)
                           console.log(`num petals = ${value}`) }])

   var petalsOffset = WatchedValue.Create(mandala.petalsOffset,
      [function(value) {   mandala.petalsOffset = value
                           renderGuides()
                           console.log(`petals offset = ${value}`)}])

   var drawHalfGuides = WatchedValue.Create(mandala.drawHalfGuides,
      [ function(value) {  mandala.drawHalfGuides = value
                           renderGuides()
                           console.log(`draw half guides : ${mandala.drawHalfGuides}`)}])

   // ---------------------------------------------------------
   // handlers
   // ---------------------------------------------------------
   function onBodyLoad()
   {
      createCanvases(  {canvasOrder, canvasSize, canvasX, canvasY} )

      $('#cursorCanvasId')[0].oncontextmenu = function(){return false;}

      // --- DUCTWORK ---
      // num petals
      let numPetalsRangeCallback = myRangeInput.createRange({id:'numPetalsId',
         containerId:'numPetalsRangeContainer',
         onInputHandler:numPetals.set,
         initialValue:mandala.numPetals,
         min:Mandala.minPetals, max:Mandala.maxPetals, step:1})

      // hook range input up to external changes in num petals value
      numPetals.addSetCallback(numPetalsRangeCallback)

      // petal offset
      let petalsOffsetCB = myRangeInput.createRange({id:'petalsOffsetId',
         containerId:'petalsOffsetRangeContainer',
         onInputHandler:petalsOffset.set,
         initialValue:mandala.petalsOffset,
         min:-0.5, max:0.5, step:0.1})

      // --- draw setup ---
      cursorGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:getInputCanvas()})
      outputGraphicsEngine = new GraphicsEngine.GraphicsEngine({canvas:getDrawCanvas()})

      drawEngine = new DrawEngine.DrawEngine({ inputCanvas:getInputCanvas(),
                                                drawCursorGraphics:cursorGraphicsEngine.execute.bind(cursorGraphicsEngine),
                                                drawOutputGraphics:drawOutput })

      // --- UI INIT ---
      // TODO: better way to do this?
      $('#numPetalsSpanId').html(mandala.numPetals)
      $('#halfGuidesCheckboxId')[0].checked = mandala.drawHalfGuides
      $('#drawModeSelectId')[0].value = drawEngine.currentDrawMode.name

      // DRAW
      render()
   }

   // ---------------------------------------------------------
   function onClearDrawingButton()
   {
      var cvs = $(`#${drawingCanvasId}`)[0]
      var ctx = cvs.getContext("2d");
      ctx.clearRect(0, 0, cvs.width, cvs.height);
   }

   // ---------------------------------------------------------
   function onDoubleSpokesButton()
   {
      numPetals.set(mandala.numPetals * 2)
   }

   // ---------------------------------------------------------
   function onHalveSpokesButton()
   {
      if (0 == mandala.numPetals % 2 && mandala.numPetals >= 4)
      {
         numPetals.set(mandala.numPetals / 2)
      }
   }

   // ----------------------------------------------------------------------
   function onPlusOneSpokeButton()
   {
      numPetals.set(mandala.numPetals + 1)
   }
   function onMinusOneSpokeButton()
   {
      if (mandala.numPetals > 2)
      {
         numPetals.set(mandala.numPetals - 1)
      }
   }

   // -----------------------------------------------------------------------
   function onChangeDrawHalfGuides(event)
   {
      //TODO : check this out in different browsers
      checked = event.target.checked

      drawHalfGuides.set( checked ) // mandala.drawHalfGuides ? false : true )<<this works long as initial state is right
   }

   // --------------------------------------------------------------------------
   function onChangeDrawMode(event)
   {
      console.log(`change draw mode to: ${event.target.value}`)
      drawEngine.setDrawMode(event.target.value)
   }

   </script>

   <div id='configDivId'>
      <span>number of petals:</span>
      <button id='halveSpokesButtonId' onclick='onHalveSpokesButton()'>&lt;&lt;</button>
      <button id='PlusOneSpokeButtonId' onclick='onMinusOneSpokeButton()'>-</button>
      <div id='numPetalsRangeContainer' style='display:inline-block;'></div>
      <button id='PlusOneSpokeButtonId' onclick='onPlusOneSpokeButton()'>+</button>
      <button id='doubleSpokesButtonId' onclick='onDoubleSpokesButton()'>&gt;&gt;</button>
      <span id='numPetalsSpanId'>n/a</span>
      <div id='petalsOffsetRangeContainer' style='display:inline-block;'></div>
      <span>half guides:</span><input type='checkbox' id='halfGuidesCheckboxId' checked='true' onchange="onChangeDrawHalfGuides(event)">
      <!-- <button id='spokesOffButtonId' onclick='onSpokesOffButton()'>off</button> -->
      <!-- <input type='range' id='spokesOpacityId' min='0' max='1' step='0.05' onchange='onSpokesOpacityChange()'/> -->
      <br>
      <select id='drawModeSelectId' onchange='onChangeDrawMode(event)'>
         <option value='lines'>Lines</option>
         <option value='freeform'>Freeform</option>
      </select>
      <button id='clearDrawingButtonId' onclick='onClearDrawingButton()'>Clear</button>
   </div>

   <!-- <canvas id="myCanvasId" width="1500" height="1500" style="border:1px solid #000000;"> -->
</canvas>
